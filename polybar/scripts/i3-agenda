#!/usr/bin/env python3

from __future__ import print_function

import argparse
import datetime
import json
import os
import os.path
import pickle
import subprocess
import time
import pathlib
from typing import Optional, List

from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build, Resource

CONF_DIR = pathlib.Path("~/.cache/i3-agenda").expanduser()
TMP_TOKEN = CONF_DIR / "i3agenda_google_token.pickle"
CACHE_PATH = CONF_DIR / "i3agenda_cache.txt"
SCOPES = [
    'https://www.googleapis.com/auth/calendar.readonly',
    'https://www.googleapis.com/auth/gmail.readonly'
]
DEFAULT_CAL_WEBPAGE = 'https://calendar.google.com/calendar/r/day'

# i3blocks use this envvar to check the click
button = os.getenv("BLOCK_BUTTON", "")

parser = argparse.ArgumentParser(description='Show next Google Calendar event')
parser.add_argument('--credentials',
                    '-c',
                    type=str,
                    default='',
                    help='path to your credentials.json file')
parser.add_argument('--cachettl',
                    '-ttl',
                    type=int,
                    default=30,
                    help='time for cache to be kept in minutes')
parser.add_argument(
    '--update',
    '-u',
    action='store_true',
    default=False,
    help=
    'when using this flag it will not load previous results from cache, it will however save new results to cache. You can use this flag to refresh all the cache forcefully'
)
parser.add_argument(
    '--closest-event-url',
    action='store_true',
    default=False,
    help='when using this flag it will get the meeting url of the last event')
parser.add_argument(
    '--ids',
    '-i',
    type=str,
    default=[],
    nargs='+',
    help=
    'list of calendar ids to fetch, space separated. If none is specified all calendars will be fetched'
)
parser.add_argument(
    '--maxres',
    '-r',
    type=int,
    default=10,
    help=
    'max number of events to query Google\'s API for each of your calendars. Increase this number if you have lot of events in your google calendar'
)
parser.add_argument('--today',
                    '-d',
                    action='store_true',
                    help='print only today events')
parser.add_argument('--no-event-text',
                    default="No events",
                    metavar="TEXT",
                    help='text to display when there are no events')
parser.add_argument(
    '--hide-event-after',
    type=int,
    default=-1,
    help=
    'minutes to show events after they start before showing the next event. If not specified, the current event will be shown until it ends'
)
parser.add_argument(
    '--date-format',
    type=str,
    default="%%d/%%m",
    help='the date format like %%d/%%m/%%y. Default is %%d/%%m')

parser.add_argument(
    '--only-if-email-is-attendee',
    metavar="my_email",
    type=str,
    help=
    'only show events which has these emails (separated by comma) as attendee')

parser.add_argument('--email-check',
                    action='store_true',
                    default=False,
                    help='email check')


class Event:
    def __init__(self, summary: str, is_allday: bool, unix_time: float,
                 end_time: float, location: str):
        self.is_allday = is_allday
        self.summary = summary
        self.unix_time = unix_time
        self.end_time = end_time
        self.location = location


class EventEncoder(json.JSONEncoder):
    def default(self, o):  # pylint: disable=E0202
        if isinstance(o, Event):
            return o.__dict__
        else:
            return json.JSONEncoder.default(self, o)


def main():
    args = parser.parse_args()

    allowed_calendars_ids = args.ids

    if args.email_check:
        email_count(args.credentials)
        return

    events = None
    if not args.update:
        events = load_cache(args.cachettl)
    if events == None:
        service = calendar_connect(args.credentials)
        events = getEvents(service, allowed_calendars_ids, args.maxres,
                           args.today, args.only_if_email_is_attendee)
        save_cache(events)

    closest = get_closest(events, args.hide_event_after)

    if args.closest_event_url:
        if not closest:
            return
        print(closest.location)
        return

    if closest is None:
        print(args.no_event_text)
        return

    if button != "":
        if button == '1':
            print("Opening calendar page...")
            subprocess.Popen(["xdg-open", DEFAULT_CAL_WEBPAGE])
        elif button == '3':
            print("Opening location link...")
            subprocess.Popen(["xdg-open", closest.location])

    event = datetime.datetime.fromtimestamp(closest.unix_time)
    today = datetime.datetime.today()
    tomorrow = datetime.datetime.today() + datetime.timedelta(days=1)

    result = closest.summary

    if (event.date() == today.date()):
        print(f"{event:%H:%M} " + result)
    elif (event.date() == tomorrow.date()):
        print(f"{event:Tomorrow at %H:%M} " + result)
    else:
        print(f"{event:%d/%m at %H:%M} " + result)


def getEventLocation(event: dict) -> str:
    if 'hangoutLink' in event and event['hangoutLink'].startswith("https"):
        return event['hangoutLink']

    if 'conferenceData' in event:
        for ep in event["conferenceData"]:
            if ep['entryPointType'] == "video" and ep["uri"].startswith(
                    "https"):
                return ep["uri"]
    if 'location' in event and event["location"].startswith("https"):
        return event["location"]
    elif 'location' in event:
        return event["location"]

    return ""


def getEvents(service,
              allowed_calendars_ids: List[str],
              max_results: int,
              today_only=False,
              my_email: str = "") -> List[Event]:
    now = datetime.datetime.utcnow()
    now_rfc3339 = now.isoformat() + 'Z'  # 'Z' indicates UTC time
    calendar_ids = []
    while True:
        calendar_list = service.calendarList().list().execute()
        for calendar_list_entry in calendar_list['items']:
            if not allowed_calendars_ids or calendar_list_entry[
                    'id'] in allowed_calendars_ids:
                calendar_ids.append(calendar_list_entry['id'])
        page_token = calendar_list.get('nextPageToken')
        if not page_token:
            break

    all = []
    for id in calendar_ids:
        if today_only:
            midnight_rfc3339 = now.replace(hour=23, minute=39,
                                           second=59).isoformat() + 'Z'
            events_result = service.events().list(
                calendarId=id,
                timeMin=now_rfc3339,
                timeMax=midnight_rfc3339,
                maxResults=max_results,
                singleEvents=True,
                orderBy='startTime').execute()
        else:
            events_result = service.events().list(
                calendarId=id,
                timeMin=now_rfc3339,
                maxResults=max_results,
                singleEvents=True,
                orderBy='startTime').execute()
        events = events_result.get('items', [])

        if not events:
            continue

        for event in events:
            if my_email:
                if not 'attendees' in event:
                    continue
                skip_it = True
                for attendee in event["attendees"]:
                    if attendee["responseStatus"] == "accepted" and \
                       attendee["email"] in [ x.strip() for x in my_email.split(",")]:
                        skip_it = False
                if skip_it:
                    continue
            end_time = get_event_time(event['end'].get(
                'dateTime', event['end'].get('date')))
            start_time = event['start'].get('dateTime',
                                            event['start'].get('date'))
            unix_time = get_event_time(start_time)
            all.append(
                Event(event['summary'], is_allday(start_time), unix_time,
                      end_time, getEventLocation(event)))

    return all


def is_allday(start_time: str) -> bool:
    return "T" not in start_time


def get_event_time(full_time: str) -> float:
    if "T" in full_time:
        format = '%Y-%m-%dT%H:%M:%S%z'
    else:
        format = '%Y-%m-%d'

    # Python introduced the ability to parse ":" in the timezone format (in strptime()) only from version 3.7 and up.
    # We need to remove the : before the timezone to support older versions
    # See https://stackoverflow.com/questions/30999230/how-to-parse-timezone-with-colon for more information
    if full_time[-3] == ":":
        full_time = full_time[:-3] + full_time[-2:]

    return time.mktime(
        datetime.datetime.strptime(full_time, format).astimezone().timetuple())


def get_closest(events: List[Event], hide_event_after: int) -> Optional[Event]:
    closest = None
    for event in events:
        # Don't show all day events
        if event.is_allday:
            continue

        # If the event already ended
        if event.end_time < time.time():
            continue

        if hide_event_after > -1:
            # If the event started more than hide_event_after ago
            if event.unix_time + 60 * hide_event_after < time.time():
                continue

        if closest is None or event.unix_time < closest.unix_time:
            closest = event

    return closest


def load_cache(cachettl: int) -> Optional[List[Event]]:
    if not os.path.exists(CACHE_PATH):
        return None

    if time.time() - os.path.getmtime(CACHE_PATH) > cachettl * 60:
        return None

    events = []

    try:
        with open(CACHE_PATH, 'r') as f:
            raw = json.loads(f.read())
            for event in raw:
                events.append(
                    Event(event['summary'], event['is_allday'],
                          event['unix_time'], event['end_time'],
                          event['location']))
        return events
    except Exception:
        # Invalid cache
        return None


def save_cache(events: List[Event]) -> None:
    with open(CACHE_PATH, 'w+') as f:
        f.write(EventEncoder().encode(events))


def get_creds(credspath: str):
    creds = None
    # The file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    CONF_DIR.mkdir(parents=True, exist_ok=True)
    if TMP_TOKEN.exists():
        with open(TMP_TOKEN, 'rb') as token:
            creds = pickle.load(token)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if not os.path.exists(credspath):
            print(
                "You need to download your credentials json file from the Google API Console and pass its path to this script"
            )
            exit(1)
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(credspath, SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open(TMP_TOKEN, 'wb') as token:
            pickle.dump(creds, token)

    return creds


def calendar_connect(credspath: str) -> Resource:
    creds = get_creds(credspath)
    return build('calendar', 'v3', credentials=creds)


def email_count(credspath: str):
    creds = get_creds(credspath)
    gmail = build('gmail', 'v1', credentials=creds)
    labels = gmail.users().labels().get(userId='me', id="INBOX").execute()
    count = labels['messagesUnread']
    if count > 0:
        print(count)


if __name__ == '__main__':
    main()
